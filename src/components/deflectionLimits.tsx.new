import React, { useState } from 'react'
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card'
import { InputWithUnit } from '@/components/ui/InputWithUnit'
import { Button } from '@/components/ui/button'
import { ChevronDown, ChevronUp } from 'lucide-react'
import presets from '@/data/deflection_presets.json'

// Define deflection limits types and constants
export interface DeflectionLimits {
  initial: {
    spanRatio: number  // Integer representing span division (e.g., 240 means span/240)
    maxLimit: number
    maxDeflection?: number  // Calculated maximum deflection in mm as an integer
  }
  short: {
    spanRatio: number  // Integer representing span division (e.g., 180 means span/180)
    maxLimit: number
    maxDeflection?: number  // Calculated maximum deflection in mm as an integer
  }
  long: {
    spanRatio: number  // Integer representing span division (e.g., 120 means span/120)
    maxLimit: number
    maxDeflection?: number  // Calculated maximum deflection in mm as an integer
  }
}

export const DeflectionLimitsCard: React.FC<{
  deflectionLimits: DeflectionLimits
  setDeflectionLimits: React.Dispatch<React.SetStateAction<DeflectionLimits>>
  span: number  // Pass span from parent to help with default calculations
}> = ({ deflectionLimits, setDeflectionLimits, span }) => {
  const [collapsed, setCollapsed] = useState(false);

  // Check if current limits exactly match a preset
  const matchPreset = (preset: typeof presets[number]) => {
    const checkSection = (
      current: { spanRatio: number, maxLimit: number, maxDeflection?: number }, 
      presetSection: { ratio: number, max: number }
    ) => {
      // Compare span ratio and max limit, converting max limit to meters
      return current.spanRatio === presetSection.ratio && 
             Math.abs(current.maxLimit - presetSection.max / 1000) < 0.001
    }

    return (
      checkSection(deflectionLimits.initial, preset.inst) &&
      checkSection(deflectionLimits.short, preset.short) &&
      checkSection(deflectionLimits.long, preset.long)
    )
  }

  // Update a specific part of the deflection limits
  const updateDeflectionLimit = (
    section: keyof DeflectionLimits, 
    property: keyof DeflectionLimits['initial'], 
    value: number
  ) => {
    setDeflectionLimits(prev => {
      const newLimits = { ...prev }
      
      if (property === 'maxDeflection') {
        // We store the calculated max deflection but don't edit it directly
        return newLimits
      }
      
      // Update the specified property
      newLimits[section] = {
        ...newLimits[section],
        [property]: value
      }
      
      // Recalculate the max deflection when span ratio or max limit changes
      newLimits[section].maxDeflection = calculateMaxDeflection(
        span,
        newLimits[section].spanRatio,
        newLimits[section].maxLimit
      )
      
      return newLimits
    })
  }

  // Calculate maximum deflection based on span and limits
  const calculateMaxDeflection = (
    span: number,  // Span in meters
    spanRatio: number,  // Span divisor (e.g., 240 means span/240)
    maxLimit: number  // Maximum limit in meters
  ): number => {
    if (spanRatio <= 0) {
      return 0
    }
    
    // Convert span to mm
    const spanMm = span * 1000
    
    // Calculate deflection by span ratio
    const ratioDeflection = spanMm / spanRatio
    
    // Convert maxLimit to mm if it's in meters
    const maxLimitMm = maxLimit < 1 ? maxLimit * 1000 : maxLimit
    
    // Return the lesser of ratio-based deflection or max limit as an integer
    return Math.round(Math.min(ratioDeflection, maxLimitMm))
  }

  // Calculate default span ratios if not set
  const getDefaultSpanRatio = (type: 'initial' | 'short' | 'long') => {
    switch(type) {
      case 'initial': return 0  // More restrictive for initial deflection
      case 'short': return 0    // Standard short-term deflection limit
      case 'long': return 0     // More allowance for long-term deflection
    }
  }

  return (
    <Card className="mb-6 lg:col-span-2 bg-[var(--card)] text-[var(--text)] border-[color:var(--border)]">
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle className="text-xl">Deflection Limits</CardTitle>
        <Button 
          variant="ghost" 
          className="p-1 h-auto" 
          onClick={() => setCollapsed(!collapsed)}
          aria-label={collapsed ? "Expand" : "Collapse"}
        >
          {collapsed ? 
            <ChevronDown className="h-5 w-5 text-[var(--text)]" /> : 
            <ChevronUp className="h-5 w-5 text-[var(--text)]" />}
        </Button>
      </CardHeader>
      
      {!collapsed && (
        <CardContent className="space-y-4">
          <div className="grid grid-cols-3 gap-4">
            {/* Initial Deflection */}
            <div className="space-y-2">
              <h3 className="text-sm font-medium text-[var(--text)] flex items-center gap-2">
                Initial 
                <span className="block text-xs font-medium text-[var(--text)] opacity-70">
                  (Max: {calculateMaxDeflection(span, deflectionLimits.initial.spanRatio, deflectionLimits.initial.maxLimit)} mm)
                </span>
              </h3>
              <div className="space-y-1.5">
                <label className="block text-xs font-medium text-[var(--text)] opacity-70">Span Ratio</label>
                <InputWithUnit
                  id="initialSpanRatio"
                  unit="L/x"
                  type="number"
                  inputMode="decimal"
                  step={10}
                  placeholder="Initial Span Ratio"
                  value={(deflectionLimits.initial.spanRatio || getDefaultSpanRatio('initial')).toString()}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                    const value = e.currentTarget.value.trim()
                    if (value === '') {
                      updateDeflectionLimit('initial', 'spanRatio', 0)
                    } else {
                      const parsedValue = parseInt(value, 10)
                      if (!isNaN(parsedValue)) {
                        updateDeflectionLimit('initial', 'spanRatio', parsedValue)
                      }
                    }
                  }}
                  className="w-full bg-[var(--input)] border-[color:var(--border)] appearance-none"
                />
              </div>
              <div className="space-y-1.5">
                <label className="block text-xs font-medium text-[var(--text)] opacity-70">Maximum Limit</label>
                  <InputWithUnit
                  id="initialMaxLimit"
                  unit="mm"
                  type="number"
                  inputMode="decimal"
                  step={1}
                  placeholder="Initial Max Limit"
                  value={(deflectionLimits.initial.maxLimit * 1000).toFixed(0)}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                    const value = e.currentTarget.value.trim()
                    if (value === '') {
                      updateDeflectionLimit('initial', 'maxLimit', 0)
                    } else {
                      const numericValue = Number(value)
                      updateDeflectionLimit('initial', 'maxLimit', numericValue / 1000)
                    }
                  }}
                  className="w-full bg-[var(--input)] border-[color:var(--border)] appearance-none"
                />
              </div>
            </div>

            {/* Short-Term Deflection */}
            <div className="space-y-2">
              <h3 className="text-sm font-medium text-[var(--text)] flex items-center gap-2">
                Short 
                <span className="block text-xs font-medium text-[var(--text)] opacity-70">
                  (Max: {calculateMaxDeflection(span, deflectionLimits.short.spanRatio, deflectionLimits.short.maxLimit)} mm)
                </span>
              </h3>
              <div className="space-y-1.5">
                <label className="block text-xs font-medium text-[var(--text)] opacity-70">Span Ratio</label>
                <InputWithUnit
                  id="shortSpanRatio"
                  unit="L/x"
                  type="number"
                  inputMode="decimal"
                  step={10}
                  placeholder="Short Span Ratio"
                  value={(deflectionLimits.short.spanRatio || getDefaultSpanRatio('short')).toString()}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                    const value = e.currentTarget.value.trim()
                    if (value === '') {
                      updateDeflectionLimit('short', 'spanRatio', 0)
                    } else {
                      const parsedValue = parseInt(value, 10)
                      if (!isNaN(parsedValue)) {
                        updateDeflectionLimit('short', 'spanRatio', parsedValue)
                      }
                    }
                  }}
                  className="w-full bg-[var(--input)] border-[color:var(--border)] appearance-none"
                />
              </div>
              <div className="space-y-1.5">
                <label className="block text-xs font-medium text-[var(--text)] opacity-70">Maximum Limit</label>
                <InputWithUnit
                  id="shortMaxLimit"
                  unit="mm"
                  type="number"
                  inputMode="decimal"
                  step={1}
                  placeholder="Short Max Limit"
                  value={(deflectionLimits.short.maxLimit * 1000).toFixed(0)}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                    const value = e.currentTarget.value.trim()
                    if (value === '') {
                      updateDeflectionLimit('short', 'maxLimit', 0)
                    } else {
                      const numericValue = Number(value)
                      updateDeflectionLimit('short', 'maxLimit', numericValue / 1000)
                    }
                  }}
                  className="w-full bg-[var(--input)] border-[color:var(--border)] appearance-none"
                />
              </div>
            </div>

            {/* Long-Term Deflection */}
            <div className="space-y-2">
              <h3 className="text-sm font-medium text-[var(--text)] flex items-center gap-2">
                Long 
                <span className="block text-xs font-medium text-[var(--text)] opacity-70">
                  (Max: {calculateMaxDeflection(span, deflectionLimits.long.spanRatio, deflectionLimits.long.maxLimit)} mm)
                </span>
              </h3>
              <div className="space-y-1.5">
                <label className="block text-xs font-medium text-[var(--text)] opacity-70">Span Ratio</label>
                <InputWithUnit
                  id="longSpanRatio"
                  unit="L/x"
                  type="number"
                  inputMode="decimal"
                  step={10}
                  placeholder="Long Span Ratio"
                  value={(deflectionLimits.long.spanRatio || getDefaultSpanRatio('long')).toString()}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                    const value = e.currentTarget.value.trim()
                    if (value === '') {
                      updateDeflectionLimit('long', 'spanRatio', 0)
                    } else {
                      const parsedValue = parseInt(value, 10)
                      if (!isNaN(parsedValue)) {
                        updateDeflectionLimit('long', 'spanRatio', parsedValue)
                      }
                    }
                  }}
                  className="w-full bg-[var(--input)] border-[color:var(--border)] appearance-none"
                />
              </div>
              <div className="space-y-1.5">
                <label className="block text-xs font-medium text-[var(--text)] opacity-70">Maximum Limit</label>
                <InputWithUnit
                  id="longMaxLimit"
                  unit="mm"
                  type="number"
                  inputMode="decimal"
                  step={1}
                  placeholder="Long Max Limit"
                  value={(deflectionLimits.long.maxLimit * 1000).toFixed(0)}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                    const value = e.currentTarget.value.trim()
                    if (value === '') {
                      updateDeflectionLimit('long', 'maxLimit', 0)
                    } else {
                      const numericValue = Number(value)
                      updateDeflectionLimit('long', 'maxLimit', numericValue / 1000)
                    }
                  }}
                  className="w-full bg-[var(--input)] border-[color:var(--border)] appearance-none"
                />
              </div>
            </div>
          </div>
              
          {/* Preset Buttons */}
          <div className="mt-4 grid grid-cols-3 gap-4 appearance-none">
            {presets.map((preset) => (
              <Button 
                key={preset.id}
                variant={matchPreset(preset) ? "outline" : "outline"}
                size="sm"
                className={`${matchPreset(preset) ? "border-accent" : ""}  bg-[var(--card)]`}
                onClick={() => {
                  setDeflectionLimits({
                    initial: {
                      spanRatio: preset.inst.ratio,
                      maxLimit: preset.inst.max / 1000,
                      maxDeflection: calculateMaxDeflection(span, preset.inst.ratio, preset.inst.max / 1000)
                    },
                    short: {
                      spanRatio: preset.short.ratio,
                      maxLimit: preset.short.max / 1000,
                      maxDeflection: calculateMaxDeflection(span, preset.short.ratio, preset.short.max / 1000)
                    },
                    long: {
                      spanRatio: preset.long.ratio,
                      maxLimit: preset.long.max / 1000,
                      maxDeflection: calculateMaxDeflection(span, preset.long.ratio, preset.long.max / 1000)
                    }
                  })
                }}
              >
                {preset.name}
              </Button>
            ))}
          </div>
        </CardContent>
      )}
    </Card>
  )
}